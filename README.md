lru# Simulation-Project
CSARCH2 Cache Simulation Project 8-way BSA + LRU

Test Case # 1 Analysis
For test case #1 our groups interpretation is that the sequence can only go up to 64 maximum, as such considering the nature of the sequence and our replacement algorithm which is a least recently used algorithm, the amount of hits in the test case will depend on what our user inputted n will be. If it's >32, the hits will generally be n*3, while there will be n misses which is the first pass when we are still populating the cache. However, once n starts becoming greater than 32, we noticed that the cache hits will gradually get lower in comparison to n, and the misses will be greater. This is due to the fact that at that point we're accessing more blocks than there is slots available for them. In which case, there will come a point where n will be sufficiently large enough where everything will be a miss because we're replacing the lowest numbers in the sequence with a higher number making said higher number be technically the youngest in terms of the system clock, and then when the next pass comes these higher numbers which happen to be at the end of the sequence will be one of the last to be replaced, generally right before their turn in the sequence is up.

Test Case # 2 Analysis
For test case #2, how we interpreted it is that since it is stated that n is the number of cache blocks, test case 2 can only go up to 128, and the memory blocks will dictate how many blocks we have in the memory to access, as such, say our user input for the memory blocks is 10, we would access the the memory 10 times and in our cache simulator it would take random integers from 0 to 128. From there, we would then have a random amount of cache hits or misses  from every iteration due to accessing the memory differently every simulation.

Test Case # 3 Analysis
For test case #3, for our project 8-way BSA + LRU, because of the nature of our replacement algorithm naturally the most amount of hits that we will be able to simulate is when n = 16, as this allows for the blocks to never be replaced. For every n that is below 16 our cache misses will always just be n*2! This is due to the fact that test case 3 when n is 16 or below will always have a memory access sequence that will always fit into the amount of cache blocks we have which is 32. What makes this test case unique however, is that it repeats the middle part. This makes the test case' hit rate be generally higher than if the sequence was just 2n and makes the breaking point where the sequence will always be misses higher as the first half of the sequence will logically be fighting for less spots in the cache block.
